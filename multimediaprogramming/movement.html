<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Multimedia Programming - Movement</title>

        <link type="text/css"  rel="stylesheet" href="css/jquery-ui-1.8.14.custom.css"/>	
        <link type="text/css" rel=StyleSheet href="css/module.css">	
        <link type="text/css" rel=StyleSheet href="css/ide.css">
        <!--
        JQuery Stuff
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        -->
        <script type="text/javascript" src="js/jquery-1.6.2.min.js"></script>
        <script type="text/javascript" src="js/jquery-ui-1.8.14.custom.min.js"></script>
        <script type="text/javascript" src="js/module.js"></script>
        <!-- Syntax Highlighter
        <script type="text/javascript" src="js/hightlighter/shCore.js"></script> 
        <script type="text/javascript" src="js/hightlighter/shProcessing.js"></script> 
        <link type="text/css" rel="stylesheet" href="css/highlighter/shCoreDefault.css"/>
        -->
        <!-- Code Mirror -->
        <link rel="stylesheet" href="css/cm/processingide.css">
        <script type="text/javascript" src="js/cm/codemirror.js"></script>
        <script type="text/javascript" src="js/cm/clike.js"></script>
        <link rel="stylesheet" href="css/cm/processing.css">
        <!-- Processing.js -->
        <script type="text/javascript" src="js/processing-1.3.0.min.js"></script>

        <style>.CodeMirror {border: 2px inset #dee;}</style>


    </head>
    <body>

        <div id="wrapper">

            <div id="container">
                <div id="tabs">
                    <ul>
                        <li><a href="index.html">Back</a></li>
                        <li><a href="#tabs-1">Goals</a></li>
                        <li><a href="#tabs-2">Linear Movement</a></li>
                        <li><a href="#tabs-3">Wavy Movement</a></li>
                        <li><a href="#tabs-4">Others</a></li>
                        <li><a href="#tabs-5">Example</a></li>
                    </ul>
                    <div id="tabs-1" class="tab">

                        <h1>Goals</h1>
                        <ul>
                            <li>Linear Movement</li>
                            <ul>
                                <li>Basic</li>
                                <li>Angle</li>
                                <li>Changing Angles</li>
                                <li>Timing</li>
                            </ul>
                            <li>Wavy Movement</li>
                            <ul>
                                <li>Sin or Cos?</li>
                                <li>Circular</li>
                                <li>Making Decisions</li>
                                <li>Death and Decay</li>
                            </ul>
                            <li>Other Movement</li>
                            <ul>
                                <li>Attract and Repel</li>
                                <li>Perlin Noise</li>
                            </ul>
                        </ul>
                        <div class="rule"></div>
                        <h1>Resources</h1>
                        <p>
                            <a href="http://processing.org/learning/trig/">http://processing.org/learning/trig/</a><br />
                            <a href="http://processing.org/learning/topics/bouncybubbles.html">http://processing.org/learning/topics/bouncybubbles.html</a><br />
                            <a href="http://processing.org/learning/topics/reflection1.html">http://processing.org/learning/topics/reflection1.html</a><br />
                        </p>
                        <div class="rule"></div>
                        <div class="quote">
                            "A human act once set in motion flows on forever to the great account. Our deathlessness is in what we do, not in what we are." ~ George Meredith
                        </div>

                    </div>
                    <div id="tabs-2" class="tab">
                        <h1>Linear Movement</h1>
                        <p>
                            Linear movement is the most basic movement type we can have. There are however several ways to program linear movement.
                        </p>
                        <p>
                            First we're going to take a look at a basic linear movement:
                        </p>
                        <form><textarea class="processingide" style="height:240px">
float xPos = 20, yPos = 200;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  ellipse(xPos, yPos, 20, 20); 
  xPos++;
}</textarea></form>
                        <div class="rule"></div>
                        <h1>Angle Based Linear Movement</h1>
                        <p>
                            Now if we want to move linearly in the direction of some angle, let's call it "angle" then we need to update
                            the xPos and yPos coordinate variables (for whatever shape we're moving) using the cos and sin of the "angle" angle variable.
                        </p>
                        <p>
                            Take a look:
                        </p>
                        <form><textarea class="processingide" style="height:260px">
float xPos = 0, yPos = 200, angle = -PI/8;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  xPos += cos(angle);
  yPos += sin(angle);
  ellipse(xPos, yPos, 20, 20); 
}</textarea></form>

                        <div class="rule"></div>
                        <h1>Changing Angles</h1>
                        <p>
                            What about using a data source like the mouse position to generate the angle? It's still linear movement, but much
                            more interesting.
                        </p>
                        <form><textarea class="processingide" style="height:285px">
float xPos = 200, yPos = 200, angle = -PI/8;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  angle = atan2(mouseY - yPos, mouseX - xPos);
  xPos += cos(angle);
  yPos += sin(angle);
  ellipse(xPos, yPos, 20, 20); 
}</textarea></form>

                        <div class="rule"></div>
                        <h1>Timing Linear Movement</h1>
                        <p>
                            We can use a simple integer as a timer for any motion (or in any object). We don't have to time only motion, we can time a fill,
                            an animation, practically anything.
                        </p>
                        <p>
                            Check out the timer and where it's used in this example:
                        </p>
                        <form><textarea class="processingide" style="height:430px">
float xPos = 200, yPos = 200, angle = -PI/4;
int timer = 0;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  xPos += cos(angle);
  yPos += sin(angle);
  fill(timer * 6);
  ellipse(xPos, yPos, 20, 20); 
  timer++;
  if (timer > 40) {
    angle += PI/2;
    timer = 0;
  }
}</textarea></form>
                        <div class="whitespace"></div>
                    </div>
                    <div id="tabs-3" class="tab">
                        <h1>Wavy Movement</h1>
                        <p>
                            Wavy movement is usually performed by using sin and cos for the direction to travel but in a slightly different way.
                        </p>
                        <p>
                            Take a look at this simple example which could use sin or cos:
                        </p>
                        <form><textarea class="processingide" style="height:240px">
float xPos = 200, yPos = 200, angle = 0;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  ellipse(xPos + 40 * sin(angle), yPos, 20, 20); 
  angle += 0.04;
}</textarea></form>
                        <div class="rule"></div>
                        <h1>Circular Movement</h1>
                        <p>
                            If we combine cos and sin to effect the x and y positions at the same time, using the same angle, we will get a circular movement.
                        </p>
                        <p>
                            Have a look:
                        </p>
                        <form><textarea class="processingide" style="height:260px">
float xPos = 200, yPos = 200, angle = 0;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  ellipse(xPos + 40*cos(angle), yPos + 40*sin(angle),20,20); 
  angle += 0.04;
}</textarea></form>
                        <p>
                            Notice the number 40 in there? That's a chosen number, it could be anything. Since sin and cos are two functions that return numbers
                            <strong>oscillating</strong> between <strong>( -1, 1 )</strong>, that number becomes the <strong>radius</strong> of the 
                            circular motion in this example.
                        </p>
                        <p>
                            Also note that the angle is always increasing at a constant rate. We could say the angle is increasing linearly with time. Why 0.04?
                            It's a nice number that makes the movement smooth... That's all. Changing this number would simply make the circles faster or slower.
                        </p>
                        <div class="rule"></div>
                        <h1>Vehicles Making Decisions</h1>
                        <p>
                            So what if we can move back and forth or in a circle? Well things become more interesting when we start changing the location and adding
                            in a little bit of random behavior.
                        </p>
                        <form><textarea class="processingide" style="height:380px">
float xPos = 200, yPos = 200, angle = 0; speed = 0.4;
int dir = 1;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  xPos += speed * cos(angle);
  yPos += speed * sin(angle);
  angle += 0.04 * dir;
  if (random(0, 16) < 1) {
    dir *= -1;
  }
  ellipse(xPos, yPos, 20, 20);
}</textarea></form>
                        <p>
                            Two things to notice here:
                        </p>
                        <p>
                            The use of an integer to remember which way we should be increasing our angle. The "dir" variable is simply 1 or -1 and that will
                            control how our angle is updated.
                        </p>
                        <p>
                            The other is the use of the random function. Notice it's usage here: <span class="code">if (random(0, 16) < 1)</span> This
                            use will give a 1 / 16 chance of the dir variable getting changed. That's what gives this dot it's random walk.
                        </p>
                        <div class="rule"></div>
                        <h1>Death and Decay - Timing</h1>
                        <p>
                            So how would we give our little vehicle a lifespan. Eventually it walks completely offscreen, but what if we wanted to control how long
                            it would be until that happened? Well we'd need to time it somehow using an integer.
                        </p>
                        <form><textarea class="processingide" style="height:520px">
float xPos = 200, yPos = 200, angle = 0; speed = 0.4;
int dir = 1, timer = 0;
void setup() {
  size(400, 400); noStroke(); background(255);
}
void draw() {
  background(255);
  fill(timer);
  xPos += speed * cos(angle);
  yPos += speed * sin(angle);
  angle += 0.04 * dir;
  if (random(0, 16) < 1) {
    dir *= -1;
  }
  ellipse(xPos, yPos, 20, 20);
  timer++;
  if (timer > 255) {
    xPos = yPos = 200; timer = 0;
  }
}</textarea></form>

                        <p>
                            Notice how when the timer reaches 255, we reset the xPos and yPos to the center, and reset the timer to 0 so the whole loop will
                            happen again with this object.
                        </p>
                        <div class="whitespace"></div>
                    </div>
                    <div id="tabs-4" class="tab">
                        <h1>Attract and Repel</h1>
                        <p>
                            We've seen a basic attraction equation before, but let's take another look:
                        </p>
                        <form><textarea class="processingide" style="height:265px">
float xPos = 200, yPos = 200;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  xPos += (mouseX - xPos)/30;
  yPos += (mouseY - yPos)/30;
  ellipse(xPos, yPos, 20, 20);
}</textarea></form>
                        <p>
                            Notice what makes the attraction happen? It's the vector (distance and direction) to the mouse position divided by some number (30).
                            So what we are adding to the xPos and yPos is a piece of that vector to the mouse. The more we divide this vector, the
                            slower the object will move towards the mouse?
                        </p>
                        <p>
                            How about repulsion?
                        </p>
                        <form><textarea class="processingide" style="height:265px">
float xPos = 200, yPos = 200;
void setup() {
  size(400, 400); fill(0);
}
void draw() {
  background(255);
  xPos -= (mouseX - xPos)/300;
  yPos -= (mouseY - yPos)/300;
  ellipse(xPos, yPos, 20, 20);
}</textarea></form>
                        <p>
                            Notice that instead of adding the vector in the direction of the mouse, we're subtracting it from the xPos and yPos variables.
                            Also, we had to increase the divisor (30) to 300 in this case, because otherwise our object would move too fast and would leave
                            the screen before we had a chance to find out what happened.
                        </p>
                        <p>
                            There is another way to do repulsion and it has to do with how we calculate the vector:<br />
                            <span class="code">xPos += (xPos - mouseX)/300;</span> <br />
                            <span class="code">yPos += (yPos - mouseY)/300;</span> <br />
                            Now the vector faces the opposite direction. When we add this to our object (not subtracting) we're actually adding a vector facing
                            away from the mouse.
                        </p>
                        <div class="rule"></div>
                        <h1>Frictionless Physics Attraction (orbiting)</h1>
                        <p>
                            Attraction can be physics based, including a mass and force.
                        </p>
                        <p>
                            Here is an example using PVectors:
                        </p>
                        <form><textarea class="processingide" style="height:500px">
PVector pos, vel, acc;
float mass, force;
void setup() {
  size(600, 600);
  pos = new PVector(random(width), random(height));
  vel = new PVector();
  acc = new PVector();
  mass = 1;
  force = 1;
}
void draw() {
  background(255);
  //attraction to the center of the screen
  PVector diff = PVector.sub(new PVector(width/2, height/2), pos); //the edge between our object and the center of the screen
  float distance = diff.mag(); //the distance between our object and the center
  if (distance > 32.0) { //as long as we're not within 32 pixels of the center
    diff.div(distance); //the further we are, the less attraction
    diff.mult(mass * force); //multiply by the mass of our object
    acc.add(diff); //add to acceleration
  }
  vel.add(acc); //add acceleration to velocity
  acc.set(0,0,0); //reset acceleration
  pos.add(vel); //update position
  //ellipse
  ellipse(pos.x, pos.y, 20, 20);
}</textarea></form>
                        <div class="rule"></div>
                        <h1>Perlin Noise</h1>
                        <p>
                            Perlin noise is a smooth random noise function. Have you ever used the "clouds" filter in photoshop? Then you've seen Perlin noise.
                        </p>
                        <p>
                            Let's take a look at drawing some Perlin noise:
                        </p>
                        <form><textarea class="processingide" style="height:335px">
void setup() {
  size(400, 400); background(255); noStroke();
}
void draw() {
  int bit = 8;
  for (int i = 0; i < width; i += bit) {
    for (int j = 0; j < height; j += bit) {
      float bright = noise(i * 0.005, j * 0.005);
      fill(bright * 255);
      rect(i, j, bit, bit);
    }
  }
}</textarea></form>
                        <p>
                            Now imagine if we controlled the angle of some object based on the brightness of the noise where the object's position was?
                        </p>
                        <form><textarea class="processingide" style="height:335px">
float xPos = 200, yPos = 200;
void setup() {
  size(400, 400); background(255); noStroke();
}
void draw() {
  float angle = 45 * noise(xPos * 0.005, yPos * 0.005);
  xPos += cos(angle);
  yPos += sin(angle);
  
  int bit = 32;
  for (int i = 0; i < width; i += bit) {
    for (int j = 0; j < height; j += bit) {
      
      float bright = noise(i * 0.005, j * 0.005);
      fill(bright * 255);
      rect(i, j, bit, bit);
    }
  }
  fill(255, 0, 0);
  ellipse(xPos, yPos, 16, 16);
}</textarea></form>
                        <div class="whitespace"></div>
                    </div>

                    <div id="tabs-5" class="tab">
                        <form><textarea class="processingide" style="height:580px">
int newNoiseSeed = (int) random(100000);
int maxBall = 256;
ArrayList<Ball> objects = new ArrayList<Ball>();

void setup() {
  size(600, 600);
  background(255);
  smooth();
}

void keyPressed() {
  if (key == ' ') background(255);
}

void draw() {
  if (mousePressed && objects.size() < maxBall) {
    objects.add( new Ball( mouseX, mouseY ));
  }

  for (int i = 0; i < objects.size(); i++) {
    Ball b = objects.get(i);
    b.addPerlin();
    b.update();
    b.drawMe();
  }
}

class Ball {
  PVector pos, pPos, vel, acc;
  float damp, weight;
  color c;

  Ball(float xPos, float yPos) {
    pos = new PVector(xPos, yPos);
    pPos = new PVector(0, 0);
    vel = new PVector(0, 0);
    acc = new PVector(0, 0);
    damp = 0.99;
    weight = 1;
    c = color(0, random(128), random(128, 255), 16);
  }

  void update() {
    vel.add(acc);
    vel.mult(damp);
    pPos.set(pos.x, pos.y, 0);
    pos.add(vel);
    acc.set(0, 0, 0);
    outside();
  }

  void outside() {
    if (pos.x > width || pos.x < 0
      || pos.y > height || pos.y < 0) {
      objects.remove(this);
    };
  }
  
  void addPerlin() {
    float depth = 0.006;
    float bright = 15 * noise(pos.x * depth, pos.y * depth, newNoiseSeed);
    PVector perlin = new PVector( cos(bright), sin(bright) );
    //perlin.mult(0.04);
    acc.add( perlin );
    vel.limit(4);
  }

  void drawMe() {
    stroke(c);
    strokeWeight(weight);
    line(pos.x, pos.y, pPos.x, pPos.y);
  }
}</textarea></form>
                                        </div>

                                        </div>


                                        </div>

                                        </div>
                                        </div>


                                        </body>
                                        </html>
